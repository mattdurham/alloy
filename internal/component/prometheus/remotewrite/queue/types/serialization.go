// Code generated by bebop; DO NOT EDIT.

package types

import (
	"io"
	"wellquite.org/bebop/runtime"
)

type SeriesGroup struct {
	Strings []string
	Series []TimeSeriesBinary
	Metadata []MetaSeriesBinary
}

var _ runtime.Bebop = (*SeriesGroup)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *SeriesGroup) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *SeriesGroup) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *SeriesGroup) MarshalBebop(buf []byte) ([]byte, error) {
	size := self.SizeBebop()
	if len(buf) < size {
		buf = make([]byte, size)
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *SeriesGroup) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *SeriesGroup) SizeBebop() int {
	return SizeBebopOfArrayOfString_serialization(self.Strings) + SizeBebopOfArrayOfTimeSeriesBinary_serialization(self.Series) + SizeBebopOfArrayOfMetaSeriesBinary_serialization(self.Metadata)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *SeriesGroup) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = BebopEncodeArrayOfStringEncoder_serialization(encoder, self.Strings)
	if err != nil {
		return err
	}
	err = BebopEncodeArrayOfTimeSeriesBinaryEncoder_serialization(encoder, self.Series)
	if err != nil {
		return err
	}
	err = BebopEncodeArrayOfMetaSeriesBinaryEncoder_serialization(encoder, self.Metadata)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *SeriesGroup) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = BebopMarshalArrayOfStringAt_serialization(buf, offset, self.Strings)
	if err != nil {
		return offset, err
	}
	offset, err = BebopMarshalArrayOfTimeSeriesBinaryAt_serialization(buf, offset, self.Series)
	if err != nil {
		return offset, err
	}
	offset, err = BebopMarshalArrayOfMetaSeriesBinaryAt_serialization(buf, offset, self.Metadata)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *SeriesGroup) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		value, m, err := BebopDecodeArrayOfStringDecoder_serialization(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.Strings = value
	}
	{
		value, m, err := BebopDecodeArrayOfTimeSeriesBinaryDecoder_serialization(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.Series = value
	}
	{
		value, m, err := BebopDecodeArrayOfMetaSeriesBinaryDecoder_serialization(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.Metadata = value
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *SeriesGroup) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		value, nextOffset, err := BebopUnmarshalArrayOfStringAt_serialization(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Strings = value
	}
	{
		value, nextOffset, err := BebopUnmarshalArrayOfTimeSeriesBinaryAt_serialization(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Series = value
	}
	{
		value, nextOffset, err := BebopUnmarshalArrayOfMetaSeriesBinaryAt_serialization(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Metadata = value
	}
	return offset, nil
}

type TimeSeriesBinary struct {
	LabelsNames []int32
	LabelsValues []int32
	TS int64
	Value float64
	Hash uint64
	Histograms Histograms
}

var _ runtime.Bebop = (*TimeSeriesBinary)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *TimeSeriesBinary) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *TimeSeriesBinary) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *TimeSeriesBinary) MarshalBebop(buf []byte) ([]byte, error) {
	size := self.SizeBebop()
	if len(buf) < size {
		buf = make([]byte, size)
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *TimeSeriesBinary) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *TimeSeriesBinary) SizeBebop() int {
	return SizeBebopOfArrayOfInt32_serialization(self.LabelsNames) + SizeBebopOfArrayOfInt32_serialization(self.LabelsValues) + 8 + 8 + 8 + self.Histograms.SizeBebop()
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *TimeSeriesBinary) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = BebopEncodeArrayOfInt32Encoder_serialization(encoder, self.LabelsNames)
	if err != nil {
		return err
	}
	err = BebopEncodeArrayOfInt32Encoder_serialization(encoder, self.LabelsValues)
	if err != nil {
		return err
	}
	err = encoder.EncodeInt64(self.TS)
	if err != nil {
		return err
	}
	err = encoder.EncodeFloat64(self.Value)
	if err != nil {
		return err
	}
	err = encoder.EncodeUint64(self.Hash)
	if err != nil {
		return err
	}
	err = self.Histograms.BebopEncodeEncoder(encoder)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *TimeSeriesBinary) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = BebopMarshalArrayOfInt32At_serialization(buf, offset, self.LabelsNames)
	if err != nil {
		return offset, err
	}
	offset, err = BebopMarshalArrayOfInt32At_serialization(buf, offset, self.LabelsValues)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalInt64At(buf, offset, self.TS)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalFloat64At(buf, offset, self.Value)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalUint64At(buf, offset, self.Hash)
	if err != nil {
		return offset, err
	}
	offset, err = self.Histograms.BebopMarshalAt(buf, offset)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *TimeSeriesBinary) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		value, m, err := BebopDecodeArrayOfInt32Decoder_serialization(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.LabelsNames = value
	}
	{
		value, m, err := BebopDecodeArrayOfInt32Decoder_serialization(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.LabelsValues = value
	}
	{
		value, m, err := decoder.DecodeInt64()
		n += m
		if err != nil {
			return n, err
		}
		self.TS = value
	}
	{
		value, m, err := decoder.DecodeFloat64()
		n += m
		if err != nil {
			return n, err
		}
		self.Value = value
	}
	{
		value, m, err := decoder.DecodeUint64()
		n += m
		if err != nil {
			return n, err
		}
		self.Hash = value
	}
	{
		m, err := self.Histograms.BebopDecodeDecoder(decoder)
		n += m
		if err != nil {
			return n, err
		}
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *TimeSeriesBinary) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		value, nextOffset, err := BebopUnmarshalArrayOfInt32At_serialization(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.LabelsNames = value
	}
	{
		value, nextOffset, err := BebopUnmarshalArrayOfInt32At_serialization(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.LabelsValues = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalInt64At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.TS = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalFloat64At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Value = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalUint64At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Hash = value
	}
	{
		nextOffset, err := self.Histograms.BebopUnmarshalAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
	}
	return offset, nil
}

type MetaSeriesBinary struct {
	LabelsNames []int32
	LabelsValues []int32
	TS int64
	Value float64
	Hash uint64
	Histograms Histograms
}

var _ runtime.Bebop = (*MetaSeriesBinary)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *MetaSeriesBinary) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *MetaSeriesBinary) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *MetaSeriesBinary) MarshalBebop(buf []byte) ([]byte, error) {
	size := self.SizeBebop()
	if len(buf) < size {
		buf = make([]byte, size)
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *MetaSeriesBinary) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *MetaSeriesBinary) SizeBebop() int {
	return SizeBebopOfArrayOfInt32_serialization(self.LabelsNames) + SizeBebopOfArrayOfInt32_serialization(self.LabelsValues) + 8 + 8 + 8 + self.Histograms.SizeBebop()
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *MetaSeriesBinary) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = BebopEncodeArrayOfInt32Encoder_serialization(encoder, self.LabelsNames)
	if err != nil {
		return err
	}
	err = BebopEncodeArrayOfInt32Encoder_serialization(encoder, self.LabelsValues)
	if err != nil {
		return err
	}
	err = encoder.EncodeInt64(self.TS)
	if err != nil {
		return err
	}
	err = encoder.EncodeFloat64(self.Value)
	if err != nil {
		return err
	}
	err = encoder.EncodeUint64(self.Hash)
	if err != nil {
		return err
	}
	err = self.Histograms.BebopEncodeEncoder(encoder)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *MetaSeriesBinary) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = BebopMarshalArrayOfInt32At_serialization(buf, offset, self.LabelsNames)
	if err != nil {
		return offset, err
	}
	offset, err = BebopMarshalArrayOfInt32At_serialization(buf, offset, self.LabelsValues)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalInt64At(buf, offset, self.TS)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalFloat64At(buf, offset, self.Value)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalUint64At(buf, offset, self.Hash)
	if err != nil {
		return offset, err
	}
	offset, err = self.Histograms.BebopMarshalAt(buf, offset)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *MetaSeriesBinary) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		value, m, err := BebopDecodeArrayOfInt32Decoder_serialization(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.LabelsNames = value
	}
	{
		value, m, err := BebopDecodeArrayOfInt32Decoder_serialization(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.LabelsValues = value
	}
	{
		value, m, err := decoder.DecodeInt64()
		n += m
		if err != nil {
			return n, err
		}
		self.TS = value
	}
	{
		value, m, err := decoder.DecodeFloat64()
		n += m
		if err != nil {
			return n, err
		}
		self.Value = value
	}
	{
		value, m, err := decoder.DecodeUint64()
		n += m
		if err != nil {
			return n, err
		}
		self.Hash = value
	}
	{
		m, err := self.Histograms.BebopDecodeDecoder(decoder)
		n += m
		if err != nil {
			return n, err
		}
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *MetaSeriesBinary) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		value, nextOffset, err := BebopUnmarshalArrayOfInt32At_serialization(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.LabelsNames = value
	}
	{
		value, nextOffset, err := BebopUnmarshalArrayOfInt32At_serialization(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.LabelsValues = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalInt64At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.TS = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalFloat64At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Value = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalUint64At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Hash = value
	}
	{
		nextOffset, err := self.Histograms.BebopUnmarshalAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
	}
	return offset, nil
}

type Histogram struct {
	Count HistogramCount
	Sum float64
	Schema int32
	ZeroThreshold float64
	ZeroCount HistogramZeroCount
	NegativeSpans []BucketSpan
	NegativeBuckets []int64
	NegativeCounts []float64
	PositiveSpans []BucketSpan
	PositiveBuckets []int64
	PositiveCounts []float64
	ResetHint int32
	TimestampMillisecond int64
}

var _ runtime.Bebop = (*Histogram)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *Histogram) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *Histogram) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *Histogram) MarshalBebop(buf []byte) ([]byte, error) {
	size := self.SizeBebop()
	if len(buf) < size {
		buf = make([]byte, size)
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *Histogram) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *Histogram) SizeBebop() int {
	return 17 + 8 + 4 + 8 + 17 + SizeBebopOfArrayOfBucketSpan_serialization(self.NegativeSpans) + SizeBebopOfArrayOfInt64_serialization(self.NegativeBuckets) + SizeBebopOfArrayOfFloat64_serialization(self.NegativeCounts) + SizeBebopOfArrayOfBucketSpan_serialization(self.PositiveSpans) + SizeBebopOfArrayOfInt64_serialization(self.PositiveBuckets) + SizeBebopOfArrayOfFloat64_serialization(self.PositiveCounts) + 4 + 8
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *Histogram) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = self.Count.BebopEncodeEncoder(encoder)
	if err != nil {
		return err
	}
	err = encoder.EncodeFloat64(self.Sum)
	if err != nil {
		return err
	}
	err = encoder.EncodeInt32(self.Schema)
	if err != nil {
		return err
	}
	err = encoder.EncodeFloat64(self.ZeroThreshold)
	if err != nil {
		return err
	}
	err = self.ZeroCount.BebopEncodeEncoder(encoder)
	if err != nil {
		return err
	}
	err = BebopEncodeArrayOfBucketSpanEncoder_serialization(encoder, self.NegativeSpans)
	if err != nil {
		return err
	}
	err = BebopEncodeArrayOfInt64Encoder_serialization(encoder, self.NegativeBuckets)
	if err != nil {
		return err
	}
	err = BebopEncodeArrayOfFloat64Encoder_serialization(encoder, self.NegativeCounts)
	if err != nil {
		return err
	}
	err = BebopEncodeArrayOfBucketSpanEncoder_serialization(encoder, self.PositiveSpans)
	if err != nil {
		return err
	}
	err = BebopEncodeArrayOfInt64Encoder_serialization(encoder, self.PositiveBuckets)
	if err != nil {
		return err
	}
	err = BebopEncodeArrayOfFloat64Encoder_serialization(encoder, self.PositiveCounts)
	if err != nil {
		return err
	}
	err = encoder.EncodeInt32(self.ResetHint)
	if err != nil {
		return err
	}
	err = encoder.EncodeInt64(self.TimestampMillisecond)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *Histogram) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = self.Count.BebopMarshalAt(buf, offset)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalFloat64At(buf, offset, self.Sum)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalInt32At(buf, offset, self.Schema)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalFloat64At(buf, offset, self.ZeroThreshold)
	if err != nil {
		return offset, err
	}
	offset, err = self.ZeroCount.BebopMarshalAt(buf, offset)
	if err != nil {
		return offset, err
	}
	offset, err = BebopMarshalArrayOfBucketSpanAt_serialization(buf, offset, self.NegativeSpans)
	if err != nil {
		return offset, err
	}
	offset, err = BebopMarshalArrayOfInt64At_serialization(buf, offset, self.NegativeBuckets)
	if err != nil {
		return offset, err
	}
	offset, err = BebopMarshalArrayOfFloat64At_serialization(buf, offset, self.NegativeCounts)
	if err != nil {
		return offset, err
	}
	offset, err = BebopMarshalArrayOfBucketSpanAt_serialization(buf, offset, self.PositiveSpans)
	if err != nil {
		return offset, err
	}
	offset, err = BebopMarshalArrayOfInt64At_serialization(buf, offset, self.PositiveBuckets)
	if err != nil {
		return offset, err
	}
	offset, err = BebopMarshalArrayOfFloat64At_serialization(buf, offset, self.PositiveCounts)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalInt32At(buf, offset, self.ResetHint)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalInt64At(buf, offset, self.TimestampMillisecond)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *Histogram) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		m, err := self.Count.BebopDecodeDecoder(decoder)
		n += m
		if err != nil {
			return n, err
		}
	}
	{
		value, m, err := decoder.DecodeFloat64()
		n += m
		if err != nil {
			return n, err
		}
		self.Sum = value
	}
	{
		value, m, err := decoder.DecodeInt32()
		n += m
		if err != nil {
			return n, err
		}
		self.Schema = value
	}
	{
		value, m, err := decoder.DecodeFloat64()
		n += m
		if err != nil {
			return n, err
		}
		self.ZeroThreshold = value
	}
	{
		m, err := self.ZeroCount.BebopDecodeDecoder(decoder)
		n += m
		if err != nil {
			return n, err
		}
	}
	{
		value, m, err := BebopDecodeArrayOfBucketSpanDecoder_serialization(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.NegativeSpans = value
	}
	{
		value, m, err := BebopDecodeArrayOfInt64Decoder_serialization(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.NegativeBuckets = value
	}
	{
		value, m, err := BebopDecodeArrayOfFloat64Decoder_serialization(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.NegativeCounts = value
	}
	{
		value, m, err := BebopDecodeArrayOfBucketSpanDecoder_serialization(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.PositiveSpans = value
	}
	{
		value, m, err := BebopDecodeArrayOfInt64Decoder_serialization(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.PositiveBuckets = value
	}
	{
		value, m, err := BebopDecodeArrayOfFloat64Decoder_serialization(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.PositiveCounts = value
	}
	{
		value, m, err := decoder.DecodeInt32()
		n += m
		if err != nil {
			return n, err
		}
		self.ResetHint = value
	}
	{
		value, m, err := decoder.DecodeInt64()
		n += m
		if err != nil {
			return n, err
		}
		self.TimestampMillisecond = value
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *Histogram) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		nextOffset, err := self.Count.BebopUnmarshalAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalFloat64At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Sum = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalInt32At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Schema = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalFloat64At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.ZeroThreshold = value
	}
	{
		nextOffset, err := self.ZeroCount.BebopUnmarshalAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
	}
	{
		value, nextOffset, err := BebopUnmarshalArrayOfBucketSpanAt_serialization(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.NegativeSpans = value
	}
	{
		value, nextOffset, err := BebopUnmarshalArrayOfInt64At_serialization(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.NegativeBuckets = value
	}
	{
		value, nextOffset, err := BebopUnmarshalArrayOfFloat64At_serialization(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.NegativeCounts = value
	}
	{
		value, nextOffset, err := BebopUnmarshalArrayOfBucketSpanAt_serialization(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.PositiveSpans = value
	}
	{
		value, nextOffset, err := BebopUnmarshalArrayOfInt64At_serialization(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.PositiveBuckets = value
	}
	{
		value, nextOffset, err := BebopUnmarshalArrayOfFloat64At_serialization(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.PositiveCounts = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalInt32At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.ResetHint = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalInt64At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.TimestampMillisecond = value
	}
	return offset, nil
}

type FloatHistogram struct {
	Count HistogramCount
	Sum float64
	Schema int32
	ZeroThreshold float64
	ZeroCount HistogramZeroCount
	NegativeSpans []BucketSpan
	NegativeDeltas []int64
	NegativeCounts []float64
	PositiveSpans []BucketSpan
	PositiveDeltas []int64
	PositiveCounts []float64
	ResetHint int32
	TimestampMillisecond int64
}

var _ runtime.Bebop = (*FloatHistogram)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *FloatHistogram) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *FloatHistogram) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *FloatHistogram) MarshalBebop(buf []byte) ([]byte, error) {
	size := self.SizeBebop()
	if len(buf) < size {
		buf = make([]byte, size)
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *FloatHistogram) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *FloatHistogram) SizeBebop() int {
	return 17 + 8 + 4 + 8 + 17 + SizeBebopOfArrayOfBucketSpan_serialization(self.NegativeSpans) + SizeBebopOfArrayOfInt64_serialization(self.NegativeDeltas) + SizeBebopOfArrayOfFloat64_serialization(self.NegativeCounts) + SizeBebopOfArrayOfBucketSpan_serialization(self.PositiveSpans) + SizeBebopOfArrayOfInt64_serialization(self.PositiveDeltas) + SizeBebopOfArrayOfFloat64_serialization(self.PositiveCounts) + 4 + 8
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *FloatHistogram) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = self.Count.BebopEncodeEncoder(encoder)
	if err != nil {
		return err
	}
	err = encoder.EncodeFloat64(self.Sum)
	if err != nil {
		return err
	}
	err = encoder.EncodeInt32(self.Schema)
	if err != nil {
		return err
	}
	err = encoder.EncodeFloat64(self.ZeroThreshold)
	if err != nil {
		return err
	}
	err = self.ZeroCount.BebopEncodeEncoder(encoder)
	if err != nil {
		return err
	}
	err = BebopEncodeArrayOfBucketSpanEncoder_serialization(encoder, self.NegativeSpans)
	if err != nil {
		return err
	}
	err = BebopEncodeArrayOfInt64Encoder_serialization(encoder, self.NegativeDeltas)
	if err != nil {
		return err
	}
	err = BebopEncodeArrayOfFloat64Encoder_serialization(encoder, self.NegativeCounts)
	if err != nil {
		return err
	}
	err = BebopEncodeArrayOfBucketSpanEncoder_serialization(encoder, self.PositiveSpans)
	if err != nil {
		return err
	}
	err = BebopEncodeArrayOfInt64Encoder_serialization(encoder, self.PositiveDeltas)
	if err != nil {
		return err
	}
	err = BebopEncodeArrayOfFloat64Encoder_serialization(encoder, self.PositiveCounts)
	if err != nil {
		return err
	}
	err = encoder.EncodeInt32(self.ResetHint)
	if err != nil {
		return err
	}
	err = encoder.EncodeInt64(self.TimestampMillisecond)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *FloatHistogram) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = self.Count.BebopMarshalAt(buf, offset)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalFloat64At(buf, offset, self.Sum)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalInt32At(buf, offset, self.Schema)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalFloat64At(buf, offset, self.ZeroThreshold)
	if err != nil {
		return offset, err
	}
	offset, err = self.ZeroCount.BebopMarshalAt(buf, offset)
	if err != nil {
		return offset, err
	}
	offset, err = BebopMarshalArrayOfBucketSpanAt_serialization(buf, offset, self.NegativeSpans)
	if err != nil {
		return offset, err
	}
	offset, err = BebopMarshalArrayOfInt64At_serialization(buf, offset, self.NegativeDeltas)
	if err != nil {
		return offset, err
	}
	offset, err = BebopMarshalArrayOfFloat64At_serialization(buf, offset, self.NegativeCounts)
	if err != nil {
		return offset, err
	}
	offset, err = BebopMarshalArrayOfBucketSpanAt_serialization(buf, offset, self.PositiveSpans)
	if err != nil {
		return offset, err
	}
	offset, err = BebopMarshalArrayOfInt64At_serialization(buf, offset, self.PositiveDeltas)
	if err != nil {
		return offset, err
	}
	offset, err = BebopMarshalArrayOfFloat64At_serialization(buf, offset, self.PositiveCounts)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalInt32At(buf, offset, self.ResetHint)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalInt64At(buf, offset, self.TimestampMillisecond)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *FloatHistogram) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		m, err := self.Count.BebopDecodeDecoder(decoder)
		n += m
		if err != nil {
			return n, err
		}
	}
	{
		value, m, err := decoder.DecodeFloat64()
		n += m
		if err != nil {
			return n, err
		}
		self.Sum = value
	}
	{
		value, m, err := decoder.DecodeInt32()
		n += m
		if err != nil {
			return n, err
		}
		self.Schema = value
	}
	{
		value, m, err := decoder.DecodeFloat64()
		n += m
		if err != nil {
			return n, err
		}
		self.ZeroThreshold = value
	}
	{
		m, err := self.ZeroCount.BebopDecodeDecoder(decoder)
		n += m
		if err != nil {
			return n, err
		}
	}
	{
		value, m, err := BebopDecodeArrayOfBucketSpanDecoder_serialization(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.NegativeSpans = value
	}
	{
		value, m, err := BebopDecodeArrayOfInt64Decoder_serialization(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.NegativeDeltas = value
	}
	{
		value, m, err := BebopDecodeArrayOfFloat64Decoder_serialization(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.NegativeCounts = value
	}
	{
		value, m, err := BebopDecodeArrayOfBucketSpanDecoder_serialization(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.PositiveSpans = value
	}
	{
		value, m, err := BebopDecodeArrayOfInt64Decoder_serialization(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.PositiveDeltas = value
	}
	{
		value, m, err := BebopDecodeArrayOfFloat64Decoder_serialization(decoder)
		n += m
		if err != nil {
			return n, err
		}
		self.PositiveCounts = value
	}
	{
		value, m, err := decoder.DecodeInt32()
		n += m
		if err != nil {
			return n, err
		}
		self.ResetHint = value
	}
	{
		value, m, err := decoder.DecodeInt64()
		n += m
		if err != nil {
			return n, err
		}
		self.TimestampMillisecond = value
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *FloatHistogram) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		nextOffset, err := self.Count.BebopUnmarshalAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalFloat64At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Sum = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalInt32At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Schema = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalFloat64At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.ZeroThreshold = value
	}
	{
		nextOffset, err := self.ZeroCount.BebopUnmarshalAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
	}
	{
		value, nextOffset, err := BebopUnmarshalArrayOfBucketSpanAt_serialization(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.NegativeSpans = value
	}
	{
		value, nextOffset, err := BebopUnmarshalArrayOfInt64At_serialization(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.NegativeDeltas = value
	}
	{
		value, nextOffset, err := BebopUnmarshalArrayOfFloat64At_serialization(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.NegativeCounts = value
	}
	{
		value, nextOffset, err := BebopUnmarshalArrayOfBucketSpanAt_serialization(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.PositiveSpans = value
	}
	{
		value, nextOffset, err := BebopUnmarshalArrayOfInt64At_serialization(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.PositiveDeltas = value
	}
	{
		value, nextOffset, err := BebopUnmarshalArrayOfFloat64At_serialization(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.PositiveCounts = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalInt32At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.ResetHint = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalInt64At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.TimestampMillisecond = value
	}
	return offset, nil
}

type HistogramCount struct {
	IsInt bool
	IntValue uint64
	FloatValue float64
}

var _ runtime.Bebop = (*HistogramCount)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *HistogramCount) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *HistogramCount) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *HistogramCount) MarshalBebop(buf []byte) ([]byte, error) {
	size := 17
	if len(buf) < size {
		buf = make([]byte, size)
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *HistogramCount) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *HistogramCount) SizeBebop() int {
	return 17
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *HistogramCount) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = encoder.EncodeBool(self.IsInt)
	if err != nil {
		return err
	}
	err = encoder.EncodeUint64(self.IntValue)
	if err != nil {
		return err
	}
	err = encoder.EncodeFloat64(self.FloatValue)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *HistogramCount) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalBoolAt(buf, offset, self.IsInt)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalUint64At(buf, offset, self.IntValue)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalFloat64At(buf, offset, self.FloatValue)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *HistogramCount) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		value, m, err := decoder.DecodeBool()
		n += m
		if err != nil {
			return n, err
		}
		self.IsInt = value
	}
	{
		value, m, err := decoder.DecodeUint64()
		n += m
		if err != nil {
			return n, err
		}
		self.IntValue = value
	}
	{
		value, m, err := decoder.DecodeFloat64()
		n += m
		if err != nil {
			return n, err
		}
		self.FloatValue = value
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *HistogramCount) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		value, nextOffset, err := runtime.BebopUnmarshalBoolAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.IsInt = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalUint64At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.IntValue = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalFloat64At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.FloatValue = value
	}
	return offset, nil
}

type HistogramZeroCount struct {
	IsInt bool
	IntValue uint64
	FloatValue float64
}

var _ runtime.Bebop = (*HistogramZeroCount)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *HistogramZeroCount) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *HistogramZeroCount) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *HistogramZeroCount) MarshalBebop(buf []byte) ([]byte, error) {
	size := 17
	if len(buf) < size {
		buf = make([]byte, size)
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *HistogramZeroCount) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *HistogramZeroCount) SizeBebop() int {
	return 17
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *HistogramZeroCount) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = encoder.EncodeBool(self.IsInt)
	if err != nil {
		return err
	}
	err = encoder.EncodeUint64(self.IntValue)
	if err != nil {
		return err
	}
	err = encoder.EncodeFloat64(self.FloatValue)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *HistogramZeroCount) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalBoolAt(buf, offset, self.IsInt)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalUint64At(buf, offset, self.IntValue)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalFloat64At(buf, offset, self.FloatValue)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *HistogramZeroCount) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		value, m, err := decoder.DecodeBool()
		n += m
		if err != nil {
			return n, err
		}
		self.IsInt = value
	}
	{
		value, m, err := decoder.DecodeUint64()
		n += m
		if err != nil {
			return n, err
		}
		self.IntValue = value
	}
	{
		value, m, err := decoder.DecodeFloat64()
		n += m
		if err != nil {
			return n, err
		}
		self.FloatValue = value
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *HistogramZeroCount) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		value, nextOffset, err := runtime.BebopUnmarshalBoolAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.IsInt = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalUint64At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.IntValue = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalFloat64At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.FloatValue = value
	}
	return offset, nil
}

type BucketSpan struct {
	Offset int32
	Length uint32
}

var _ runtime.Bebop = (*BucketSpan)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *BucketSpan) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *BucketSpan) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *BucketSpan) MarshalBebop(buf []byte) ([]byte, error) {
	size := 8
	if len(buf) < size {
		buf = make([]byte, size)
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *BucketSpan) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this struct uses when
// serialized to Bebop.
func (self *BucketSpan) SizeBebop() int {
	return 8
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *BucketSpan) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = encoder.EncodeInt32(self.Offset)
	if err != nil {
		return err
	}
	err = encoder.EncodeUint32(self.Length)
	if err != nil {
		return err
	}

	return err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *BucketSpan) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalInt32At(buf, offset, self.Offset)
	if err != nil {
		return offset, err
	}
	offset, err = runtime.BebopMarshalUint32At(buf, offset, self.Length)
	if err != nil {
		return offset, err
	}

	return offset, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *BucketSpan) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	{
		value, m, err := decoder.DecodeInt32()
		n += m
		if err != nil {
			return n, err
		}
		self.Offset = value
	}
	{
		value, m, err := decoder.DecodeUint32()
		n += m
		if err != nil {
			return n, err
		}
		self.Length = value
	}
	return n, nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *BucketSpan) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	{
		value, nextOffset, err := runtime.BebopUnmarshalInt32At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Offset = value
	}
	{
		value, nextOffset, err := runtime.BebopUnmarshalUint32At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}
		self.Length = value
	}
	return offset, nil
}

type Histograms struct {
	Histogram *Histogram
	FloatHistogram *FloatHistogram
}

var _ runtime.Bebop = (*Histograms)(nil)

// EncodeBebop writes the value to the writer, serialized as Bebop.
func (self *Histograms) EncodeBebop(writer io.Writer) error {
	return self.BebopEncodeEncoder(runtime.NewEncoder(writer))
}

// DecodeBebop attempts to read Bebop from the reader and to
// deserialize it into the value.
func (self *Histograms) DecodeBebop(reader io.Reader) error {
	_, err := self.BebopDecodeDecoder(runtime.NewDecoder(reader))
	return err
}

// MarshalBebop writes the value into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func (self *Histograms) MarshalBebop(buf []byte) ([]byte, error) {
	size := self.SizeBebop()
	if len(buf) < size {
		buf = make([]byte, size)
	}
	_, err := self.BebopMarshalAt(buf, 0)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into the value.
func (self *Histograms) UnmarshalBebop(buf []byte) (int, error) {
	return self.BebopUnmarshalAt(buf, 0)
}

// SizeBebop returns the number of bytes this message uses when
// serialized to Bebop.
func (self *Histograms) SizeBebop() (size int) {
	size = 5 // uint32 length prefix plus trailing 0x0

	if self.Histogram != nil {
		size += self.Histogram.SizeBebop() + 1
	}
	if self.FloatHistogram != nil {
		size += self.FloatHistogram.SizeBebop() + 1
	}

	return size
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *Histograms) BebopEncodeEncoder(encoder *runtime.Encoder) (err error) {
	err = encoder.EncodeUint32(uint32(self.SizeBebop() - 4))
	if err != nil {
		return err
	}

	if self.Histogram != nil {
		err = encoder.EncodeUint8(1)
		if err != nil {
			return err
		}
		err = self.Histogram.BebopEncodeEncoder(encoder)
		if err != nil {
			return err
		}
	}

	if self.FloatHistogram != nil {
		err = encoder.EncodeUint8(2)
		if err != nil {
			return err
		}
		err = self.FloatHistogram.BebopEncodeEncoder(encoder)
		if err != nil {
			return err
		}
	}

	return encoder.EncodeUint8(0)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *Histograms) BebopMarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalUint32At(buf, offset, uint32(self.SizeBebop() - 4))
	if err != nil {
		return offset, err
	}

	if self.Histogram != nil {
		offset, err = runtime.BebopMarshalUint8At(buf, offset, 1)
		if err != nil {
			return offset, err
		}
		offset, err = self.Histogram.BebopMarshalAt(buf, offset)
		if err != nil {
			return offset, err
		}
	}

	if self.FloatHistogram != nil {
		offset, err = runtime.BebopMarshalUint8At(buf, offset, 2)
		if err != nil {
			return offset, err
		}
		offset, err = self.FloatHistogram.BebopMarshalAt(buf, offset)
		if err != nil {
			return offset, err
		}
	}

	return runtime.BebopMarshalUint8At(buf, offset, 0)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *Histograms) BebopDecodeDecoder(decoder *runtime.Decoder) (n int, err error) {
	lengthUint32, n, err := decoder.DecodeUint32()
	if err != nil {
		return n, err
	}

	length := int(lengthUint32)

	for lim := length + 3; n < lim; {
		index, m, err := decoder.DecodeUint8()
		n += m
		if err != nil {
			return n, err
		}

		switch index {
		case 1:
			var value Histogram
			m, err := value.BebopDecodeDecoder(decoder)
			n += m
			if err != nil {
				return n, err
			}
			self.Histogram = &value

		case 2:
			var value FloatHistogram
			m, err := value.BebopDecodeDecoder(decoder)
			n += m
			if err != nil {
				return n, err
			}
			self.FloatHistogram = &value

		default:
			m, err = decoder.DiscardN(lim - n)
			n += m
			if err != nil {
				return n, err
			}
		}
	}

	_, m, err := decoder.DecodeUint8()
	n += m

	if n != length+4 {
		return n, runtime.ErrBadLengthPrefix
	}
	return n, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func (self *Histograms) BebopUnmarshalAt(buf []byte, offset int) (nextOffset int, err error) {
	lengthUint32, offset, err := runtime.BebopUnmarshalUint32At(buf, offset)
	if err != nil {
		return offset, err
	}

	end := offset + int(lengthUint32) - 1

	for offset < end {
		index, nextOffset, err := runtime.BebopUnmarshalUint8At(buf, offset)
		offset = nextOffset
		if err != nil {
			return offset, err
		}

		switch index {
		case 1:
			var value Histogram
			nextOffset, err := value.BebopUnmarshalAt(buf, offset)
			offset = nextOffset
			if err != nil {
				return offset, err
			}
			self.Histogram = &value

		case 2:
			var value FloatHistogram
			nextOffset, err := value.BebopUnmarshalAt(buf, offset)
			offset = nextOffset
			if err != nil {
				return offset, err
			}
			self.FloatHistogram = &value

		default:
			offset = end
		}
	}

	_, offset, err = runtime.BebopUnmarshalUint8At(buf, offset)

	if offset != end+1 {
		return offset, runtime.ErrBadLengthPrefix
	}
	return offset, err
}

// EncodeBebopArrayOfBucketSpan_serialization writes the array to the writer, serialized as Bebop.
func EncodeBebopArrayOfBucketSpan_serialization(writer io.Writer, ary []BucketSpan) error {
	return BebopEncodeArrayOfBucketSpanEncoder_serialization(runtime.NewEncoder(writer), ary)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopEncodeArrayOfBucketSpanEncoder_serialization(encoder *runtime.Encoder, ary []BucketSpan) (err error) {
	err = encoder.EncodeUint32(uint32(len(ary)))
	if err != nil {
		return err
	}

	for idx := range ary {
		err = ary[idx].BebopEncodeEncoder(encoder)
		if err != nil {
			return err
		}
	}

	return nil
}

// MarshalBebopArrayOfBucketSpan_serialization writes the array into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func MarshalBebopArrayOfBucketSpan_serialization(buf []byte, ary []BucketSpan) ([]byte, error) {
	size := SizeBebopOfArrayOfBucketSpan_serialization(ary)
	if len(buf) < size {
		buf = make([]byte, size)
	}
	_, err := BebopMarshalArrayOfBucketSpanAt_serialization(buf, 0, ary)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopMarshalArrayOfBucketSpanAt_serialization(buf []byte, offset int, ary []BucketSpan) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalUint32At(buf, offset, uint32(len(ary)))
	if err != nil {
		return offset, err
	}

	for idx := range ary {
		offset, err = ary[idx].BebopMarshalAt(buf, offset)
		if err != nil {
			return offset, err
		}
	}

	return offset, nil
}

// DecodeBebopArrayOfBucketSpan_serialization attempts to read Bebop from the reader and to
// deserialize it into an array of []BucketSpan.
func DecodeBebopArrayOfBucketSpan_serialization(reader io.Reader) ([]BucketSpan, error) {
	ary, _, err := BebopDecodeArrayOfBucketSpanDecoder_serialization(runtime.NewDecoder(reader))
	return ary, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopDecodeArrayOfBucketSpanDecoder_serialization(decoder *runtime.Decoder) ([]BucketSpan, int, error) {
	length, n, err := decoder.DecodeUint32()
	if err != nil {
		return nil, n, err
	}

	ary := make([]BucketSpan, int(length))
	for idx := range ary {
		m, err := ary[idx].BebopDecodeDecoder(decoder)
		n += m
		if err != nil {
			return nil, n, err
		}
	}

	return ary, n, nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into an array of []BucketSpan.
func UnmarshalBebopArrayOfBucketSpan_serialization(buf []byte) ([]BucketSpan, int, error) {
	return BebopUnmarshalArrayOfBucketSpanAt_serialization(buf, 0)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopUnmarshalArrayOfBucketSpanAt_serialization(buf []byte, offset int) ([]BucketSpan, int, error) {
	length, offset, err := runtime.BebopUnmarshalUint32At(buf, offset)
	if err != nil {
		return nil, offset, err
	}

	ary := make([]BucketSpan, int(length))
	for idx := range ary {
		nextOffset, err := ary[idx].BebopUnmarshalAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return nil, offset, err
		}
	}

	return ary, offset, nil
}

// SizeBebopOf returns the number of bytes this array uses when
// serialized to Bebop.
func SizeBebopOfArrayOfBucketSpan_serialization(ary []BucketSpan) int {
	return 4 + (len(ary) * 8)
}

// EncodeBebopArrayOfFloat64_serialization writes the array to the writer, serialized as Bebop.
func EncodeBebopArrayOfFloat64_serialization(writer io.Writer, ary []float64) error {
	return BebopEncodeArrayOfFloat64Encoder_serialization(runtime.NewEncoder(writer), ary)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopEncodeArrayOfFloat64Encoder_serialization(encoder *runtime.Encoder, ary []float64) (err error) {
	err = encoder.EncodeUint32(uint32(len(ary)))
	if err != nil {
		return err
	}

	for idx := range ary {
		err = encoder.EncodeFloat64(ary[idx])
		if err != nil {
			return err
		}
	}

	return nil
}

// MarshalBebopArrayOfFloat64_serialization writes the array into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func MarshalBebopArrayOfFloat64_serialization(buf []byte, ary []float64) ([]byte, error) {
	size := SizeBebopOfArrayOfFloat64_serialization(ary)
	if len(buf) < size {
		buf = make([]byte, size)
	}
	_, err := BebopMarshalArrayOfFloat64At_serialization(buf, 0, ary)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopMarshalArrayOfFloat64At_serialization(buf []byte, offset int, ary []float64) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalUint32At(buf, offset, uint32(len(ary)))
	if err != nil {
		return offset, err
	}

	for idx := range ary {
		offset, err = runtime.BebopMarshalFloat64At(buf, offset, ary[idx])
		if err != nil {
			return offset, err
		}
	}

	return offset, nil
}

// DecodeBebopArrayOfFloat64_serialization attempts to read Bebop from the reader and to
// deserialize it into an array of []float64.
func DecodeBebopArrayOfFloat64_serialization(reader io.Reader) ([]float64, error) {
	ary, _, err := BebopDecodeArrayOfFloat64Decoder_serialization(runtime.NewDecoder(reader))
	return ary, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopDecodeArrayOfFloat64Decoder_serialization(decoder *runtime.Decoder) ([]float64, int, error) {
	length, n, err := decoder.DecodeUint32()
	if err != nil {
		return nil, n, err
	}

	ary := make([]float64, int(length))
	for idx := range ary {
		value, m, err := decoder.DecodeFloat64()
		n += m
		if err != nil {
			return nil, n, err
		}
		ary[idx] = value
	}

	return ary, n, nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into an array of []float64.
func UnmarshalBebopArrayOfFloat64_serialization(buf []byte) ([]float64, int, error) {
	return BebopUnmarshalArrayOfFloat64At_serialization(buf, 0)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopUnmarshalArrayOfFloat64At_serialization(buf []byte, offset int) ([]float64, int, error) {
	length, offset, err := runtime.BebopUnmarshalUint32At(buf, offset)
	if err != nil {
		return nil, offset, err
	}

	ary := make([]float64, int(length))
	for idx := range ary {
		value, nextOffset, err := runtime.BebopUnmarshalFloat64At(buf, offset)
		offset = nextOffset
		if err != nil {
			return nil, offset, err
		}
		ary[idx] = value
	}

	return ary, offset, nil
}

// SizeBebopOf returns the number of bytes this array uses when
// serialized to Bebop.
func SizeBebopOfArrayOfFloat64_serialization(ary []float64) int {
	return 4 + (len(ary) * 8)
}

// EncodeBebopArrayOfInt32_serialization writes the array to the writer, serialized as Bebop.
func EncodeBebopArrayOfInt32_serialization(writer io.Writer, ary []int32) error {
	return BebopEncodeArrayOfInt32Encoder_serialization(runtime.NewEncoder(writer), ary)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopEncodeArrayOfInt32Encoder_serialization(encoder *runtime.Encoder, ary []int32) (err error) {
	err = encoder.EncodeUint32(uint32(len(ary)))
	if err != nil {
		return err
	}

	for idx := range ary {
		err = encoder.EncodeInt32(ary[idx])
		if err != nil {
			return err
		}
	}

	return nil
}

// MarshalBebopArrayOfInt32_serialization writes the array into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func MarshalBebopArrayOfInt32_serialization(buf []byte, ary []int32) ([]byte, error) {
	size := SizeBebopOfArrayOfInt32_serialization(ary)
	if len(buf) < size {
		buf = make([]byte, size)
	}
	_, err := BebopMarshalArrayOfInt32At_serialization(buf, 0, ary)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopMarshalArrayOfInt32At_serialization(buf []byte, offset int, ary []int32) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalUint32At(buf, offset, uint32(len(ary)))
	if err != nil {
		return offset, err
	}

	for idx := range ary {
		offset, err = runtime.BebopMarshalInt32At(buf, offset, ary[idx])
		if err != nil {
			return offset, err
		}
	}

	return offset, nil
}

// DecodeBebopArrayOfInt32_serialization attempts to read Bebop from the reader and to
// deserialize it into an array of []int32.
func DecodeBebopArrayOfInt32_serialization(reader io.Reader) ([]int32, error) {
	ary, _, err := BebopDecodeArrayOfInt32Decoder_serialization(runtime.NewDecoder(reader))
	return ary, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopDecodeArrayOfInt32Decoder_serialization(decoder *runtime.Decoder) ([]int32, int, error) {
	length, n, err := decoder.DecodeUint32()
	if err != nil {
		return nil, n, err
	}

	ary := make([]int32, int(length))
	for idx := range ary {
		value, m, err := decoder.DecodeInt32()
		n += m
		if err != nil {
			return nil, n, err
		}
		ary[idx] = value
	}

	return ary, n, nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into an array of []int32.
func UnmarshalBebopArrayOfInt32_serialization(buf []byte) ([]int32, int, error) {
	return BebopUnmarshalArrayOfInt32At_serialization(buf, 0)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopUnmarshalArrayOfInt32At_serialization(buf []byte, offset int) ([]int32, int, error) {
	length, offset, err := runtime.BebopUnmarshalUint32At(buf, offset)
	if err != nil {
		return nil, offset, err
	}

	ary := make([]int32, int(length))
	for idx := range ary {
		value, nextOffset, err := runtime.BebopUnmarshalInt32At(buf, offset)
		offset = nextOffset
		if err != nil {
			return nil, offset, err
		}
		ary[idx] = value
	}

	return ary, offset, nil
}

// SizeBebopOf returns the number of bytes this array uses when
// serialized to Bebop.
func SizeBebopOfArrayOfInt32_serialization(ary []int32) int {
	return 4 + (len(ary) * 4)
}

// EncodeBebopArrayOfInt64_serialization writes the array to the writer, serialized as Bebop.
func EncodeBebopArrayOfInt64_serialization(writer io.Writer, ary []int64) error {
	return BebopEncodeArrayOfInt64Encoder_serialization(runtime.NewEncoder(writer), ary)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopEncodeArrayOfInt64Encoder_serialization(encoder *runtime.Encoder, ary []int64) (err error) {
	err = encoder.EncodeUint32(uint32(len(ary)))
	if err != nil {
		return err
	}

	for idx := range ary {
		err = encoder.EncodeInt64(ary[idx])
		if err != nil {
			return err
		}
	}

	return nil
}

// MarshalBebopArrayOfInt64_serialization writes the array into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func MarshalBebopArrayOfInt64_serialization(buf []byte, ary []int64) ([]byte, error) {
	size := SizeBebopOfArrayOfInt64_serialization(ary)
	if len(buf) < size {
		buf = make([]byte, size)
	}
	_, err := BebopMarshalArrayOfInt64At_serialization(buf, 0, ary)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopMarshalArrayOfInt64At_serialization(buf []byte, offset int, ary []int64) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalUint32At(buf, offset, uint32(len(ary)))
	if err != nil {
		return offset, err
	}

	for idx := range ary {
		offset, err = runtime.BebopMarshalInt64At(buf, offset, ary[idx])
		if err != nil {
			return offset, err
		}
	}

	return offset, nil
}

// DecodeBebopArrayOfInt64_serialization attempts to read Bebop from the reader and to
// deserialize it into an array of []int64.
func DecodeBebopArrayOfInt64_serialization(reader io.Reader) ([]int64, error) {
	ary, _, err := BebopDecodeArrayOfInt64Decoder_serialization(runtime.NewDecoder(reader))
	return ary, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopDecodeArrayOfInt64Decoder_serialization(decoder *runtime.Decoder) ([]int64, int, error) {
	length, n, err := decoder.DecodeUint32()
	if err != nil {
		return nil, n, err
	}

	ary := make([]int64, int(length))
	for idx := range ary {
		value, m, err := decoder.DecodeInt64()
		n += m
		if err != nil {
			return nil, n, err
		}
		ary[idx] = value
	}

	return ary, n, nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into an array of []int64.
func UnmarshalBebopArrayOfInt64_serialization(buf []byte) ([]int64, int, error) {
	return BebopUnmarshalArrayOfInt64At_serialization(buf, 0)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopUnmarshalArrayOfInt64At_serialization(buf []byte, offset int) ([]int64, int, error) {
	length, offset, err := runtime.BebopUnmarshalUint32At(buf, offset)
	if err != nil {
		return nil, offset, err
	}

	ary := make([]int64, int(length))
	for idx := range ary {
		value, nextOffset, err := runtime.BebopUnmarshalInt64At(buf, offset)
		offset = nextOffset
		if err != nil {
			return nil, offset, err
		}
		ary[idx] = value
	}

	return ary, offset, nil
}

// SizeBebopOf returns the number of bytes this array uses when
// serialized to Bebop.
func SizeBebopOfArrayOfInt64_serialization(ary []int64) int {
	return 4 + (len(ary) * 8)
}

// EncodeBebopArrayOfMetaSeriesBinary_serialization writes the array to the writer, serialized as Bebop.
func EncodeBebopArrayOfMetaSeriesBinary_serialization(writer io.Writer, ary []MetaSeriesBinary) error {
	return BebopEncodeArrayOfMetaSeriesBinaryEncoder_serialization(runtime.NewEncoder(writer), ary)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopEncodeArrayOfMetaSeriesBinaryEncoder_serialization(encoder *runtime.Encoder, ary []MetaSeriesBinary) (err error) {
	err = encoder.EncodeUint32(uint32(len(ary)))
	if err != nil {
		return err
	}

	for idx := range ary {
		err = ary[idx].BebopEncodeEncoder(encoder)
		if err != nil {
			return err
		}
	}

	return nil
}

// MarshalBebopArrayOfMetaSeriesBinary_serialization writes the array into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func MarshalBebopArrayOfMetaSeriesBinary_serialization(buf []byte, ary []MetaSeriesBinary) ([]byte, error) {
	size := SizeBebopOfArrayOfMetaSeriesBinary_serialization(ary)
	if len(buf) < size {
		buf = make([]byte, size)
	}
	_, err := BebopMarshalArrayOfMetaSeriesBinaryAt_serialization(buf, 0, ary)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopMarshalArrayOfMetaSeriesBinaryAt_serialization(buf []byte, offset int, ary []MetaSeriesBinary) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalUint32At(buf, offset, uint32(len(ary)))
	if err != nil {
		return offset, err
	}

	for idx := range ary {
		offset, err = ary[idx].BebopMarshalAt(buf, offset)
		if err != nil {
			return offset, err
		}
	}

	return offset, nil
}

// DecodeBebopArrayOfMetaSeriesBinary_serialization attempts to read Bebop from the reader and to
// deserialize it into an array of []MetaSeriesBinary.
func DecodeBebopArrayOfMetaSeriesBinary_serialization(reader io.Reader) ([]MetaSeriesBinary, error) {
	ary, _, err := BebopDecodeArrayOfMetaSeriesBinaryDecoder_serialization(runtime.NewDecoder(reader))
	return ary, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopDecodeArrayOfMetaSeriesBinaryDecoder_serialization(decoder *runtime.Decoder) ([]MetaSeriesBinary, int, error) {
	length, n, err := decoder.DecodeUint32()
	if err != nil {
		return nil, n, err
	}

	ary := make([]MetaSeriesBinary, int(length))
	for idx := range ary {
		m, err := ary[idx].BebopDecodeDecoder(decoder)
		n += m
		if err != nil {
			return nil, n, err
		}
	}

	return ary, n, nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into an array of []MetaSeriesBinary.
func UnmarshalBebopArrayOfMetaSeriesBinary_serialization(buf []byte) ([]MetaSeriesBinary, int, error) {
	return BebopUnmarshalArrayOfMetaSeriesBinaryAt_serialization(buf, 0)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopUnmarshalArrayOfMetaSeriesBinaryAt_serialization(buf []byte, offset int) ([]MetaSeriesBinary, int, error) {
	length, offset, err := runtime.BebopUnmarshalUint32At(buf, offset)
	if err != nil {
		return nil, offset, err
	}

	ary := make([]MetaSeriesBinary, int(length))
	for idx := range ary {
		nextOffset, err := ary[idx].BebopUnmarshalAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return nil, offset, err
		}
	}

	return ary, offset, nil
}

// SizeBebopOf returns the number of bytes this array uses when
// serialized to Bebop.
func SizeBebopOfArrayOfMetaSeriesBinary_serialization(ary []MetaSeriesBinary) (size int) {
	size = 4
	for idx := range ary {
		size += ary[idx].SizeBebop()
	}
	return size
}

// EncodeBebopArrayOfString_serialization writes the array to the writer, serialized as Bebop.
func EncodeBebopArrayOfString_serialization(writer io.Writer, ary []string) error {
	return BebopEncodeArrayOfStringEncoder_serialization(runtime.NewEncoder(writer), ary)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopEncodeArrayOfStringEncoder_serialization(encoder *runtime.Encoder, ary []string) (err error) {
	err = encoder.EncodeUint32(uint32(len(ary)))
	if err != nil {
		return err
	}

	for idx := range ary {
		err = encoder.EncodeString(ary[idx])
		if err != nil {
			return err
		}
	}

	return nil
}

// MarshalBebopArrayOfString_serialization writes the array into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func MarshalBebopArrayOfString_serialization(buf []byte, ary []string) ([]byte, error) {
	size := SizeBebopOfArrayOfString_serialization(ary)
	if len(buf) < size {
		buf = make([]byte, size)
	}
	_, err := BebopMarshalArrayOfStringAt_serialization(buf, 0, ary)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopMarshalArrayOfStringAt_serialization(buf []byte, offset int, ary []string) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalUint32At(buf, offset, uint32(len(ary)))
	if err != nil {
		return offset, err
	}

	for idx := range ary {
		offset, err = runtime.BebopMarshalStringAt(buf, offset, ary[idx])
		if err != nil {
			return offset, err
		}
	}

	return offset, nil
}

// DecodeBebopArrayOfString_serialization attempts to read Bebop from the reader and to
// deserialize it into an array of []string.
func DecodeBebopArrayOfString_serialization(reader io.Reader) ([]string, error) {
	ary, _, err := BebopDecodeArrayOfStringDecoder_serialization(runtime.NewDecoder(reader))
	return ary, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopDecodeArrayOfStringDecoder_serialization(decoder *runtime.Decoder) ([]string, int, error) {
	length, n, err := decoder.DecodeUint32()
	if err != nil {
		return nil, n, err
	}

	ary := make([]string, int(length))
	for idx := range ary {
		value, m, err := decoder.DecodeString()
		n += m
		if err != nil {
			return nil, n, err
		}
		ary[idx] = value
	}

	return ary, n, nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into an array of []string.
func UnmarshalBebopArrayOfString_serialization(buf []byte) ([]string, int, error) {
	return BebopUnmarshalArrayOfStringAt_serialization(buf, 0)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopUnmarshalArrayOfStringAt_serialization(buf []byte, offset int) ([]string, int, error) {
	length, offset, err := runtime.BebopUnmarshalUint32At(buf, offset)
	if err != nil {
		return nil, offset, err
	}

	ary := make([]string, int(length))
	for idx := range ary {
		value, nextOffset, err := runtime.BebopUnmarshalStringAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return nil, offset, err
		}
		ary[idx] = value
	}

	return ary, offset, nil
}

// SizeBebopOf returns the number of bytes this array uses when
// serialized to Bebop.
func SizeBebopOfArrayOfString_serialization(ary []string) (size int) {
	size = 4
	for idx := range ary {
		size += 4 + len(ary[idx])
	}
	return size
}

// EncodeBebopArrayOfTimeSeriesBinary_serialization writes the array to the writer, serialized as Bebop.
func EncodeBebopArrayOfTimeSeriesBinary_serialization(writer io.Writer, ary []TimeSeriesBinary) error {
	return BebopEncodeArrayOfTimeSeriesBinaryEncoder_serialization(runtime.NewEncoder(writer), ary)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopEncodeArrayOfTimeSeriesBinaryEncoder_serialization(encoder *runtime.Encoder, ary []TimeSeriesBinary) (err error) {
	err = encoder.EncodeUint32(uint32(len(ary)))
	if err != nil {
		return err
	}

	for idx := range ary {
		err = ary[idx].BebopEncodeEncoder(encoder)
		if err != nil {
			return err
		}
	}

	return nil
}

// MarshalBebopArrayOfTimeSeriesBinary_serialization writes the array into the buf, serialized as
// Bebop. The slice of the buf written to is returned. If the buf is too
// small, a new buf is created, written to, and returned.
func MarshalBebopArrayOfTimeSeriesBinary_serialization(buf []byte, ary []TimeSeriesBinary) ([]byte, error) {
	size := SizeBebopOfArrayOfTimeSeriesBinary_serialization(ary)
	if len(buf) < size {
		buf = make([]byte, size)
	}
	_, err := BebopMarshalArrayOfTimeSeriesBinaryAt_serialization(buf, 0, ary)
	if err != nil {
		return nil, err
	}
	return buf[:size], nil
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopMarshalArrayOfTimeSeriesBinaryAt_serialization(buf []byte, offset int, ary []TimeSeriesBinary) (nextOffset int, err error) {
	offset, err = runtime.BebopMarshalUint32At(buf, offset, uint32(len(ary)))
	if err != nil {
		return offset, err
	}

	for idx := range ary {
		offset, err = ary[idx].BebopMarshalAt(buf, offset)
		if err != nil {
			return offset, err
		}
	}

	return offset, nil
}

// DecodeBebopArrayOfTimeSeriesBinary_serialization attempts to read Bebop from the reader and to
// deserialize it into an array of []TimeSeriesBinary.
func DecodeBebopArrayOfTimeSeriesBinary_serialization(reader io.Reader) ([]TimeSeriesBinary, error) {
	ary, _, err := BebopDecodeArrayOfTimeSeriesBinaryDecoder_serialization(runtime.NewDecoder(reader))
	return ary, err
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopDecodeArrayOfTimeSeriesBinaryDecoder_serialization(decoder *runtime.Decoder) ([]TimeSeriesBinary, int, error) {
	length, n, err := decoder.DecodeUint32()
	if err != nil {
		return nil, n, err
	}

	ary := make([]TimeSeriesBinary, int(length))
	for idx := range ary {
		m, err := ary[idx].BebopDecodeDecoder(decoder)
		n += m
		if err != nil {
			return nil, n, err
		}
	}

	return ary, n, nil
}

// UnmarshalBebop attempts to read Bebop from the buf and to
// deserialize it into an array of []TimeSeriesBinary.
func UnmarshalBebopArrayOfTimeSeriesBinary_serialization(buf []byte) ([]TimeSeriesBinary, int, error) {
	return BebopUnmarshalArrayOfTimeSeriesBinaryAt_serialization(buf, 0)
}

// Not intended for public use. This method is public only so that
// other Bebop-generated code in different packages can call it.
func BebopUnmarshalArrayOfTimeSeriesBinaryAt_serialization(buf []byte, offset int) ([]TimeSeriesBinary, int, error) {
	length, offset, err := runtime.BebopUnmarshalUint32At(buf, offset)
	if err != nil {
		return nil, offset, err
	}

	ary := make([]TimeSeriesBinary, int(length))
	for idx := range ary {
		nextOffset, err := ary[idx].BebopUnmarshalAt(buf, offset)
		offset = nextOffset
		if err != nil {
			return nil, offset, err
		}
	}

	return ary, offset, nil
}

// SizeBebopOf returns the number of bytes this array uses when
// serialized to Bebop.
func SizeBebopOfArrayOfTimeSeriesBinary_serialization(ary []TimeSeriesBinary) (size int) {
	size = 4
	for idx := range ary {
		size += ary[idx].SizeBebop()
	}
	return size
}

